adic.ig <- function(modelo=fit.model,var=NA,iden=NA,nome=seq(along = model.matrix(modelo)[,1]),link="1/mu^2",maxit=20) {

#
# Descrição e detalhes:
# A saída terá gráficos da variável adicionada de um modelo ajuste com distribuição normal inversa.
#
# O S-Plus só permite ajustar a normal inversa com ligação canônica (1/mu^2). O R permite também com ligações
# inverse e log. No entanto, o R tem um bug, pois armazena sempre no objeto ajustado que utilizou a ligação canônica.
# Assim, se utilizar uma ligação que não seja a canônica no R, deve-se informar para a função através da opção link.
#
# Os dados devem estar disponíveis pelo comando attach( ).
#
# Argumentos obrigatórios:
# modelo: deve-se informar o objeto onde está o ajuste do modelo com distribuição normal inversa, caso não seja
# 	  informado, a função procurará o ajuste no objeto fit.model;
# 
# Argumentos opcionais:
# var: se não for informada, serão feitos gráficos da variável adicionada para cada variável do modelo. Se for
#      informada, serão feitos gráficos da variável adicionada para cada uma dessas variáveis. Para cada uma das
#      variáveis que já estavam no modelo (a comparação é feita utilizando o nome informado nesse objeto e o contido na
#      matriz modelo, portanto a comparação não é perfeita!), será feito o gráfico dos resíduos do modelo sem elas
#      contra o resíduo da regressão delas pelas outras do modelo. Para cada uma das variáveis que não estavam
#      no modelo, será feito o gráfico dos resíduos do modelo já ajustado contra o resíduo da regressão delas por todas
#      as variáveis explicativas do modelo. É necessário que a matriz tenha o mesmo número de linhas do modelo. Sugere-se
#      usar o comando cbind(). Uma sugestão é primeiro fazer um gráfico para as variáveis existentes no modelo e depois
#      especificar outras variáveis que não estão no modelo. A função não irá funcionar adequadamente se var tiver fatores
#      ou se var não for informado e o modelo ajustado tiver fatores. Interações também podem não funcionar direito.
#      Nestes casos é melhor fazer os ajustes dos modelos sem as variáveis/interações de interesse e rodar essa função
#      especificando o ajuste e as variáveis extras em var;
# iden: caso deseje, informe o número de observações que irá querer destacar em cada gráfico. O vetor deve
# 	conter números inteiros. A ordem que deve ser informada é a mesma das variáveis da opção var, caso seja
#	utilizada, ou deve ter a mesma ordem da matriz modelo. Os componentes do vetor iguais a 0 indicam que não se
#	quer que identifique pontos, se for um inteiro positivo irá automaticamente nos gráficos pertinentes permitir
#	que identifiquemos o número de pontos solicitados e qualquer outro valor (negativo ou decimal) parará nos
#	gráficos e irá solicitar que especifiquemos o número de pontos a ser destacado. O padrão é c(0,...,0) caso não
#	se entre com nada e c(-1,...,-1) caso se entre com qualquer coisa que não satisfaça os requisitos citados
#	de ser número inteiro, não negativo e de ter o mesmo comprimento da opção var ou da matriz modelo;
# nome: esse argumento só é utilizado caso algum dos componentes do vetor da opção iden não seja 0. Caso não
#	seja informado nada, os pontos identificados serão os números da ordem em que estão no banco de dados.
#	Caso se queira, pode-se informar um vetor de nomes ou de identificações alternativas. Obrigatoriamente
#	esse vetor deve ter o mesmo comprimento do banco de dados;
# link: padrão "1/mu^2", que é a ligação canônica (1/mu^2). Se utilizar a ligação log, informe "log" e se utilizar
#	a ligação inversa, informe "inverse";
# maxit: essa opção é utilizada nos ajustes feitos sem as covariáveis que já estavam no modelo. O padrão é maxit=20.
#
# Autor: Frederico Zanqueta Poleto <fred@poleto.com>, arquivo disponível em http://www.poleto.com
#
# Referências:
# MCCULLAGH, P. e NELDER, J. A. (1989). Generalized Linear Models. 2ª ed. Chapman and Hall, London.
# PAULA, G. A. (2003). Modelos de Regressão com apoio computacional. IME-USP, São Paulo. [Não publicado,
#    disponível em http://www.ime.usp.br/~giapaula/Book.pdf]
#
# Exemplo:
# adic.ig(ajuste,var=cbind(X1,X3,X8),iden=-1)
#

if(class(modelo)[1] != "glm") {
	stop(paste("\nA classe do objeto deveria ser glm e nao ",class(modelo),"!!!\n"))
}
if(modelo$family[[1]] != "Inverse Gaussian" & modelo$family[[1]] != "inverse.gaussian") {
	stop(paste("\nA familia do objeto deveria ser da normal inversa !!!\n"))
}
if(link!="1/mu^2") {
	if(is.null(version$language) == T) {
		stop(paste("\nO S-Plus só aceita a ligação canônica!!!\n"))
	} else {
		if(link!="inverse" & link!="log") {
			stop(paste("\nO R só aceita as ligações canônica (1/mu^2), inversa (1/mu) e log!!!\n"))
		}
	}
}

X<-model.matrix(modelo)
px<-ncol(X)
y<-modelo$y
rx<-resid(modelo,type="pearson")
wx<-modelo$weights
Wx<-diag(wx)
Fisx<- t(X)%*%Wx%*%X
Vx<-solve(Fisx)
Hx<-sqrt(Wx)%*%X%*%Vx%*%t(X)%*%sqrt(Wx)

if (is.na(var[1])) {
	var<-X[,-1]
}
p<-ncol(var)

if (is.na(iden[1])) {
	iden<-rep(0,p)
}
if(p>length(iden)) {
	iden<-rep(-1,p)
}

if (p>2) {
	if (p>8) {	
		par(mfrow=c(3,ceiling(p/3)))
	} else {
		par(mfrow=c(2,ceiling(p/2)))
	}
} else {
	par(mfrow=c(1,ceiling(p)))
}

full<-""
expli<-0
for (i in 2:px) {
	if(expli>0) {
		expli<-expli+1
		full<-paste(full,"+",dimnames(X)[[2]][i],sep="")
	} else {
		expli<-1
		full<-paste(dimnames(X)[[2]][i],sep="")
	}
}

for(i in 1:p) {
	nomei<-dimnames(var)[[2]][i]
	X1<-var[,i]
	if(sum(dimnames(X)[[2]]==nomei)==0) {
		r<-rx
		H<-Hx
		W<-Wx
		expl<-full
		sem<-""
	} else {
		expl<-""
		expli<-0
		for(j in 2:px) {
			if(dimnames(X)[[2]][j]!=nomei) {
				if(expli>0) {
					expli<-expli+1
					expl<-paste(expl,"+",dimnames(X)[[2]][j],sep="")
				} else {
					expli<-1
					expl<-paste(dimnames(X)[[2]][j],sep="")
				}
			} else {
				X2<-X[,-j]
				sem<-paste(" -",dimnames(X)[[2]][j],sep="")
			}
		}
		if (link == "1/mu^2") {
			fit <- glm(y ~ X2-1,family=inverse.gaussian,maxit=maxit)
		} else {
			if (link == "inverse") {
				fit <- glm(y ~ X2-1,family=inverse.gaussian(link=inverse),maxit=maxit)
			}
			if (link == "log") {
				fit <- glm(y ~ X2-1,family=inverse.gaussian(link=log),maxit=maxit)
			}
		}
		r<-resid(fit,type="pearson")
		w <- fit$weights
		W <- diag(w)
		Fis <- t(X2)%*%W%*%X2
		V <- solve(Fis)
		H <- sqrt(W)%*%X2%*%V%*%t(X2)%*%sqrt(W)
	}
	print(paste(nomei,"~",expl))
	v<-sqrt(W)%*%X1-H%*%sqrt(W)%*%X1
	plot(v,r,xlab=paste("resid( ",nomei," ~ .",sem," )",sep=""),ylab=paste("resid( ",dimnames(attr(modelo$terms,"factors"))[[1]][1]," ~ .",sem," )",sep=""), pch=16)
	lines(lowess(v,r))
	while ( (!is.numeric(iden[i])) || (round(iden[i],0) != iden[i]) || (iden[i] < 0) ) {
		cat("Digite o num.de pontos a ser identificado (0=nenhum) e <enter> para continuar\n")
		out <- readline()
		iden[i]<-as.numeric(out)
	}
	if(iden[i]>0) {identify(v,r,n=iden[i],labels=nome)}
}


par(mfrow=c(1,1))
if (is.null(version$language) != T) {
	cat("Ligacao utilizada:",link,". Verifique se foi a mesma que utilizou no ajuste ou informe corretamente!\n")
}
cat("\n")
}
